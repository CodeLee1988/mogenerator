// DO NOT EDIT. This file is machine-generated and constantly overwritten.
// Make changes to <$managedObjectClassName$>.swift instead.

import CoreData
<$if hasCustomBaseCaseImport$>import <$baseClassImport$><$endif$>

<$if hasAdditionalImports$>
<$foreach Import additionalImports do$>
import <$Import$>
<$endforeach do$>
<$endif$>


public extension <$managedObjectClassName$> {

    @objc <$if (hasCustomSuperclass || (hasCustomSuperentity && TemplateVar.overrideBaseClass))$>override <$endif$>public class var entityName: String {
        return "<$name$>"
    }

    @objc <$if (hasCustomSuperclass || (hasCustomSuperentity && TemplateVar.overrideBaseClass))$>override <$endif$>public class func entity(managedObjectContext: NSManagedObjectContext) -> NSEntityDescription? {
        return NSEntityDescription.entity(forEntityName: entityName, in: managedObjectContext)
    }
	
	<$if noninheritedAttributes.@count > 0$>
	public struct Attributes {<$foreach Attribute noninheritedAttributes do$>
		static let <$Attribute.name$> = "<$Attribute.name$>"<$endforeach do$>
	}
	<$endif$>

	<$if noninheritedRelationships.@count > 0$>
	public struct Relationships {<$foreach Relationship noninheritedRelationships do$>
		static let <$Relationship.name$> = "<$Relationship.name$>"<$endforeach do$>
	}
	<$endif$>

	<$if noninheritedFetchedProperties.@count > 0$>
	public struct FetchedProperties {<$foreach FetchedProperty noninheritedFetchedProperties do$>
	    static let <$FetchedProperty.name$> = "<$FetchedProperty.name$>"<$endforeach do$>
	}
	<$endif$>

	<$if hasUserInfoKeys && userInfoKeyValues.@count > 0$>
	public struct UserInfo {<$foreach UserInfo userInfoKeyValues do$>
	    static let <$UserInfo.key$> = "<$UserInfo.key$>"<$endforeach do$>
	}
	<$endif$>
    public class func fetchRequest() -> NSFetchRequest<<$sanitizedManagedObjectClassName$>> {
        return NSFetchRequest(entityName: self.entityName)
    }
	
    // MARK: - Properties
<$foreach Attribute noninheritedAttributes do$>
<$if Attribute.hasDefinedAttributeType$>	
<$if Attribute.hasScalarAttributeType$>

<$if Attribute.usesRawValueEnumType$>
	public<$if Attribute.isReadonly$> private(set)<$endif$> var <$Attribute.name$>: <$Attribute.attributeRawValueEnumType$>? {
		get {
			let key = <$managedObjectClassName$>.Attributes.<$Attribute.name$>
			willAccessValue(forKey: key)
			defer { didAccessValue(forKey: key) }

			guard let primitiveValue = primitiveValue(forKey: key) as? <$Attribute.attributeRawValueEnumType$>.RawValue else { return nil }
			return <$Attribute.attributeRawValueEnumType$>(rawValue: primitiveValue)
		}
		set {
			let key = <$managedObjectClassName$>.Attributes.<$Attribute.name$>
			willChangeValue(forKey: key)
			defer { didChangeValue(forKey: key) }

			guard let value = newValue else {
				setPrimitiveValue(nil, forKey: key)
				return
			}
			setPrimitiveValue(value.rawValue, forKey: key)
		}
	}
<$else$> <$comment usesRawValueEnumType = false $>
<$if Attribute.isOptional$>
<$if Attribute.usesScalarAttributeType$>
	public<$if Attribute.isReadonly$> private(set)<$endif$> var <$Attribute.name$>: <$Attribute.scalarAttributeType$>? {
		get {
			let key = <$managedObjectClassName$>.Attributes.<$Attribute.name$>
			willAccessValue(forKey: key)
			defer { didAccessValue(forKey: key) }

			return primitiveValue(forKey: key) as? <$Attribute.scalarAttributeType$>
		}
		set {
			let key = <$managedObjectClassName$>.Attributes.<$Attribute.name$>
			willChangeValue(forKey: key)
			defer { didChangeValue(forKey: key) }

			guard let value = newValue else {
				setPrimitiveValue(nil, forKey: key)
				return
			}
			setPrimitiveValue(value, forKey: key)
		}
	}
<$else$> <$comment usesScalarAttributeType = true but the above checks are not true $>
	@NSManaged public<$if Attribute.isReadonly$> private(set)<$endif$> var <$Attribute.name$>: NSNumber?
<$endif$>
<$else$> <$comment isOptional is not true $>
	@NSManaged public<$if Attribute.isReadonly$> private(set)<$endif$> var <$Attribute.name$>: <$if Attribute.usesScalarAttributeType$><$Attribute.scalarAttributeType$><$else$>NSNumber<$endif$>
<$endif$> <$comment isOptional $>
<$endif$> <$comment usesRawValueEnumType $>
<$else$> <$comment hasScalarAttributeType = false (object type) $>
<$if Attribute.usesRawValueEnumType$> <$comment This is here because enums with String raw value don't count as scalars $>
	public<$if Attribute.isReadonly$> private(set)<$endif$> var <$Attribute.name$>: <$Attribute.attributeRawValueEnumType$>? {
		get {
			let key = <$managedObjectClassName$>.Attributes.<$Attribute.name$>
			willAccessValue(forKey: key)
			defer { didAccessValue(forKey: key) }

			guard let primitiveValue = primitiveValue(forKey: key) as? <$Attribute.attributeRawValueEnumType$>.RawValue else { return nil }
			return <$Attribute.attributeRawValueEnumType$>(rawValue: primitiveValue)
		}
		set {
			let key = <$managedObjectClassName$>.Attributes.<$Attribute.name$>
			willChangeValue(forKey: key)
			defer { didChangeValue(forKey: key) }

			guard let value = newValue else {
				setPrimitiveValue(nil, forKey: key)
				return
			}
			setPrimitiveValue(value.rawValue, forKey: key)
		}
	}
<$elseif Attribute.usesCustomCodableAttributeType$>
		// Attribute <$Attribute.name$> with Codable type <$Attribute.objectAttributeType$>
		public<$if Attribute.isReadonly$> private(set)<$endif$> var <$Attribute.name$>: <$Attribute.objectAttributeType$>? {
			get {
				let key = <$managedObjectClassName$>.Attributes.<$Attribute.name$>
				willAccessValue(forKey: key)
				defer { didAccessValue(forKey: key) }

				guard let primitiveValue = primitiveValue(forKey: key) as? Data else {
					return nil
				}
                    
				return try? JSONDecoder().decode(<$Attribute.objectAttributeType$>.self, from: primitiveValue)
			}
			set {
				let key = <$managedObjectClassName$>.Attributes.<$Attribute.name$>
				willChangeValue(forKey: key)
				defer { didChangeValue(forKey: key) }

				let primitiveValue = try? JSONEncoder().encode(newValue)
				setPrimitiveValue(primitiveValue, forKey: key)
			}
		}
<$else$> <$comment usesRawValueEnumType = false $>
    @NSManaged public<$if Attribute.isReadonly$> private(set)<$endif$> var <$Attribute.name$>: <$Attribute.objectAttributeType$><$if Attribute.isOptional$>?<$endif$>
<$endif$> <$comment usesRawValueEnumType $>
<$endif$> <$comment hasScalarAttributrType$>
<$endif$> <$comment hasDefinedAttributeType$>
<$endforeach do$>

    // MARK: - Relationships
<$foreach Relationship noninheritedRelationships do$>
<$if Relationship.isToMany$>
    @NSManaged public var <$Relationship.name$>: Set<<$Relationship.destinationEntity.managedObjectClassName$>><$if Relationship.isOptional$>?<$endif$>
<$else$>
    @NSManaged public var <$Relationship.name$>: <$Relationship.destinationEntity.managedObjectClassName$><$if Relationship.isOptional$>?<$endif$>
<$endif$>
<$endforeach do$>

<$foreach FetchedProperty noninheritedFetchedProperties do$>
    @NSManaged public let <$FetchedProperty.name$>: [<$FetchedProperty.entity.sanitizedManagedObjectClassName$>]
<$endforeach do$>

}
